#Writing Text Instructions for Boards and Pieces (and everything you need to know about my shitty project)

##Board and Piece files (named b_name.txt and p_name.txt respectively)
	These text files define the behaviour of the game, and are separated into predefined stages entered via single characters.
	All files are read in order and start at the metadata (-1) phase, where the object's name, mesh file path, and any number of builtin or custom float properties are defines like so:

board_name

mesh.obj

variable 0 #variable with value of zero

##Board Stages and Builtin Variables

b #stage 1, define the shape of the board as an array of 2D rectangles called bounds (see code in Bound.gd)

0 0 7 7 #values are imputted as floats and interpereted depending on the stage, these 4 create a bound between 0 0 and 7 7

?1 < 2 ?3 > 2.1+0.1 8 0 7 15 #conditionals can precede a statement and stop the statement from being evaluated if they evaluate to false. Stacking conditionals like these is equivalent to an AND statement
#algebraic expressions with no spaces can also be evaluated

?2%2 <= 0 8 0 15 7

#the maximum and minimum corners of the board are mapped to (0, 0) and (1, 1) in the uvs of the imported mesh, and together determine the shape and appearance of the board

p #stage 2, UNFINISHED, is supposed to make portals from one set of squares to another set of squares that any piece (including pieces with non-continuous movement like knights) can travel through. This allows for functional boards on cubes or any object than cannot be smoothly unwrapped without comprimising appearance

t #stage 3, define the teams on the board with three floats for RGB color, two integers for their Vector2 forward direction on the board, and one integer param for friendly fire, setting to 1 will enable pieces to capture eachother and 2 will make the team unplayable

1 1 1 0 1 0 #create white team facing up with no friendly fire
#white and black teams are created implicitly if the team phase is skipped

0.5 0.2 0.7 1 -1 1 #let your imagination run wild

g #stage 4, define the piece types and how many of which will be laid out

a.txt 
b.txt
.
.
.
#define an array of piece types to call from with an integer when placing a piece

0 0 0 1 #4 integers to create piece, the first calls the team from the team array (so zero is the white team created earlier)
0 1 2 5 #the second number picks the piece type, this one will load its behaviours from b.txt
0 0 6 2 1 #the third and fourth numbers are the piece's position on the board and optional fifth number toggles "symmetry" which will copy the piece, increase its team index by 1 (modulo team count), and rotate it 180 degrees around the center of the board, here that implicitly creates the instruction 1 0 8 13
1 0 6 3 #symmetry will still be executed for this piece, but not the next one, which toggles it off
1 0 0 0 0

#look at b_default for an example of a funcitonal board

Board builtin variables
	Board variables can only be updated in stage -1, but pieces in future builds may be able to access and update board variables

scale 1 #default 1, scale multiplier of the board
piece_scale 0.2 #default 0.2, scale multiplier of pieces on the board

##Piece Stages and Builtin Variables
	Pieces have files that determine how they move.
	Everything in the piece phases are unfinished in some way or another, and everything here is subject to change.
	Every vector mentioned here really denotes a position relative to the piece's position and forward direction's rotation from the default of 0 1

name

mesh path

distance_travelled 0 #same deal as board more or less in the metadata phase

m #marking stage 1, this phase will return an array of available squares to move to in later build, automatically considering blocking and out-of-bounds and stuff

?1 1 1 1 #pieces can check positions relative to themselves to see if they are a capturable tile using the syntax here. This represents something like a pawn checking its left diagonal for a possible capture

0 1 distance_travelled +1 #later builds will support this sort of variable updating behaviour, where distance travelled will be updated if the user selects the adjacent mark

t #taking stage 2, pieces automatically capture anything in the position they move to, but extra takes can be added relative to the piece's new position

0 -1 #this will try to capture the square behind the piece's new position

c #create stage 3, create pieces relative to the new position
?distance_travelled >= 7 4 0 0 #properties on pieces or boards can be cheched as if they were any other float, the three numbers here are the type of piece to be created (4 on a default board is queen) and its location (0 0 will overwrite this piece on the board) This system effectively enables promotion

r #relocate stage 4, move piece relative to its new position

-movex -movey #movex and movey are builtin variables for the last move of the piece, this instruction will form a sort of "laser chess" behaviour, where the piece will move back to its starting position after taking whatever was there

Again, everything in the piece phase is unfinished and likely subject to change
